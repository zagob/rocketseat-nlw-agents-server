{"version":3,"file":"zod-to-json.js","sources":["../../src/zod-to-json.ts"],"sourcesContent":["import type { $ZodDate, JSONSchema } from 'zod/v4/core'\nimport { $ZodRegistry, $ZodType, toJSONSchema } from 'zod/v4/core'\n\nconst getSchemaId = (id: string, io: 'input' | 'output') => {\n  return io === 'input' ? `${id}Input` : id\n}\n\nconst getReferenceUri = (id: string, io: 'input' | 'output') => {\n  return `#/components/schemas/${getSchemaId(id, io)}`\n}\n\nfunction isZodDate(entity: unknown): entity is $ZodDate {\n  return entity instanceof $ZodType && entity._zod.def.type === 'date'\n}\n\nconst getOverride = (\n  ctx: {\n    zodSchema: $ZodType\n    jsonSchema: JSONSchema.BaseSchema\n  },\n  io: 'input' | 'output',\n) => {\n  if (io === 'output') {\n    // Allow dates to be represented as strings in output schemas\n    if (isZodDate(ctx.zodSchema)) {\n      ctx.jsonSchema.type = 'string'\n      ctx.jsonSchema.format = 'date-time'\n    }\n\n    if (ctx.zodSchema._zod.def.type === 'undefined') {\n      ctx.jsonSchema.type = 'null'\n    }\n  }\n\n  // ToDo should be unnecessary after https://github.com/colinhacks/zod/pull/4811 is released\n  // Remove propertyNames from record schemas\n  if (ctx.jsonSchema.propertyNames) {\n    delete ctx.jsonSchema.propertyNames\n  }\n\n  // ToDo should be unnecessary after https://github.com/colinhacks/zod/pull/4811 is released\n  // Transform anyOf with type: null to nullable: true\n  if (ctx.jsonSchema.anyOf && ctx.jsonSchema.anyOf.some((s) => s.type === 'null')) {\n    ctx.jsonSchema.type = ctx.jsonSchema.anyOf.find((s) => s.type !== 'null')?.type\n    ctx.jsonSchema.nullable = true\n    delete ctx.jsonSchema.anyOf\n  }\n}\n\nconst deleteInvalidProperties: (\n  schema: JSONSchema.BaseSchema,\n) => Omit<JSONSchema.BaseSchema, 'id' | '$schema'> = (schema) => {\n  const object = { ...schema }\n\n  delete object.id\n  delete object.$schema\n\n  // ToDo added in newer zod\n  delete object.$id\n\n  return object\n}\n\nexport const zodSchemaToJson: (\n  zodSchema: $ZodType,\n  registry: $ZodRegistry<{ id?: string }>,\n  io: 'input' | 'output',\n) => ReturnType<typeof deleteInvalidProperties> = (zodSchema, registry, io) => {\n  const schemaRegistryEntry = registry.get(zodSchema)\n\n  /**\n   * Checks whether the provided schema is registered in the given registry.\n   * If it is present and has an `id`, it can be referenced as component.\n   *\n   * @see https://github.com/turkerdev/fastify-type-provider-zod/issues/173\n   */\n  if (schemaRegistryEntry?.id) {\n    return { $ref: getReferenceUri(schemaRegistryEntry.id, io) }\n  }\n\n  /**\n   * Unfortunately, at the time of writing, there is no way to generate a schema with `$ref`\n   * using `toJSONSchema` and a zod schema.\n   *\n   * As a workaround, we create a zod registry containing only the specific schema we want to convert.\n   *\n   * @see https://github.com/colinhacks/zod/issues/4281\n   */\n  const tempID = 'GEN'\n  const tempRegistry = new $ZodRegistry<{ id?: string }>()\n  tempRegistry.add(zodSchema, { id: tempID })\n\n  const {\n    schemas: { [tempID]: result },\n  } = toJSONSchema(tempRegistry, {\n    metadata: registry,\n    io,\n    unrepresentable: 'any',\n    cycles: 'ref',\n    reused: 'inline',\n\n    /**\n     * The uri option only allows customizing the base path of the `$ref`, and it automatically appends a path to it.\n     * As a workaround, we set a placeholder that looks something like this:\n     *\n     * |       marker          | always added by zod | meta.id |\n     * |__SCHEMA__PLACEHOLDER__|      #/$defs/       | User    |\n     *\n     * @example `__SCHEMA__PLACEHOLDER__#/$defs/User\"`\n     * @example `__SCHEMA__PLACEHOLDER__#/$defs/Group\"`\n     *\n     * @see jsonSchemaReplaceRef\n     * @see https://github.com/colinhacks/zod/issues/4750\n     */\n    uri: () => `__SCHEMA__PLACEHOLDER__`,\n\n    override: (ctx) => getOverride(ctx, io),\n  })\n\n  const jsonSchema = deleteInvalidProperties(result)\n\n  /**\n   * Replace the previous generated placeholders with the final `$ref` value\n   */\n  const jsonSchemaReplaceRef = JSON.stringify(jsonSchema).replaceAll(\n    /\"__SCHEMA__PLACEHOLDER__#\\/\\$defs\\/(.+?)\"/g,\n    (_, id) => `\"${getReferenceUri(id, io)}\"`,\n  )\n\n  return JSON.parse(jsonSchemaReplaceRef)\n}\n\nexport const zodRegistryToJson: (\n  registry: $ZodRegistry<{ id?: string }>,\n  io: 'input' | 'output',\n) => Record<string, JSONSchema.BaseSchema> = (registry, io) => {\n  const result = toJSONSchema(registry, {\n    io,\n    unrepresentable: 'any',\n    cycles: 'ref',\n    reused: 'inline',\n    uri: (id) => getReferenceUri(id, io),\n    override: (ctx) => getOverride(ctx, io),\n  }).schemas\n\n  const jsonSchemas: Record<string, JSONSchema.BaseSchema> = {}\n\n  for (const id in result) {\n    jsonSchemas[getSchemaId(id, io)] = deleteInvalidProperties(result[id])\n  }\n\n  return jsonSchemas\n}\n"],"names":[],"mappings":";AAGA,MAAM,cAAc,CAAC,IAAY,OAA2B;AAC1D,SAAO,OAAO,UAAU,GAAG,EAAE,UAAU;AACzC;AAEA,MAAM,kBAAkB,CAAC,IAAY,OAA2B;AAC9D,SAAO,wBAAwB,YAAY,IAAI,EAAE,CAAC;AACpD;AAEA,SAAS,UAAU,QAAqC;AACtD,SAAO,kBAAkB,YAAY,OAAO,KAAK,IAAI,SAAS;AAChE;AAEA,MAAM,cAAc,CAClB,KAIA,OACG;AACH,MAAI,OAAO,UAAU;AAEnB,QAAI,UAAU,IAAI,SAAS,GAAG;AAC5B,UAAI,WAAW,OAAO;AACtB,UAAI,WAAW,SAAS;AAAA,IAC1B;AAEA,QAAI,IAAI,UAAU,KAAK,IAAI,SAAS,aAAa;AAC/C,UAAI,WAAW,OAAO;AAAA,IACxB;AAAA,EACF;AAIA,MAAI,IAAI,WAAW,eAAe;AAChC,WAAO,IAAI,WAAW;AAAA,EACxB;AAIA,MAAI,IAAI,WAAW,SAAS,IAAI,WAAW,MAAM,KAAK,CAAC,MAAM,EAAE,SAAS,MAAM,GAAG;AAC/E,QAAI,WAAW,OAAO,IAAI,WAAW,MAAM,KAAK,CAAC,MAAM,EAAE,SAAS,MAAM,GAAG;AAC3E,QAAI,WAAW,WAAW;AAC1B,WAAO,IAAI,WAAW;AAAA,EACxB;AACF;AAEA,MAAM,0BAE+C,CAAC,WAAW;AAC/D,QAAM,SAAS,EAAE,GAAG,OAAA;AAEpB,SAAO,OAAO;AACd,SAAO,OAAO;AAGd,SAAO,OAAO;AAEd,SAAO;AACT;AAEO,MAAM,kBAIqC,CAAC,WAAW,UAAU,OAAO;AAC7E,QAAM,sBAAsB,SAAS,IAAI,SAAS;AAQlD,MAAI,qBAAqB,IAAI;AAC3B,WAAO,EAAE,MAAM,gBAAgB,oBAAoB,IAAI,EAAE,EAAA;AAAA,EAC3D;AAUA,QAAM,SAAS;AACf,QAAM,eAAe,IAAI,aAAA;AACzB,eAAa,IAAI,WAAW,EAAE,IAAI,QAAQ;AAE1C,QAAM;AAAA,IACJ,SAAS,EAAE,CAAC,MAAM,GAAG,OAAA;AAAA,EAAO,IAC1B,aAAa,cAAc;AAAA,IAC7B,UAAU;AAAA,IACV;AAAA,IACA,iBAAiB;AAAA,IACjB,QAAQ;AAAA,IACR,QAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAeR,KAAK,MAAM;AAAA,IAEX,UAAU,CAAC,QAAQ,YAAY,KAAK,EAAE;AAAA,EAAA,CACvC;AAED,QAAM,aAAa,wBAAwB,MAAM;AAKjD,QAAM,uBAAuB,KAAK,UAAU,UAAU,EAAE;AAAA,IACtD;AAAA,IACA,CAAC,GAAG,OAAO,IAAI,gBAAgB,IAAI,EAAE,CAAC;AAAA,EAAA;AAGxC,SAAO,KAAK,MAAM,oBAAoB;AACxC;AAEO,MAAM,oBAGgC,CAAC,UAAU,OAAO;AAC7D,QAAM,SAAS,aAAa,UAAU;AAAA,IACpC;AAAA,IACA,iBAAiB;AAAA,IACjB,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,KAAK,CAAC,OAAO,gBAAgB,IAAI,EAAE;AAAA,IACnC,UAAU,CAAC,QAAQ,YAAY,KAAK,EAAE;AAAA,EAAA,CACvC,EAAE;AAEH,QAAM,cAAqD,CAAA;AAE3D,aAAW,MAAM,QAAQ;AACvB,gBAAY,YAAY,IAAI,EAAE,CAAC,IAAI,wBAAwB,OAAO,EAAE,CAAC;AAAA,EACvE;AAEA,SAAO;AACT;"}