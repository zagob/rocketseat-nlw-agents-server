import { $ZodRegistry, toJSONSchema, $ZodType } from "zod/v4/core";
const getSchemaId = (id, io) => {
  return io === "input" ? `${id}Input` : id;
};
const getReferenceUri = (id, io) => {
  return `#/components/schemas/${getSchemaId(id, io)}`;
};
function isZodDate(entity) {
  return entity instanceof $ZodType && entity._zod.def.type === "date";
}
const getOverride = (ctx, io) => {
  if (io === "output") {
    if (isZodDate(ctx.zodSchema)) {
      ctx.jsonSchema.type = "string";
      ctx.jsonSchema.format = "date-time";
    }
    if (ctx.zodSchema._zod.def.type === "undefined") {
      ctx.jsonSchema.type = "null";
    }
  }
  if (ctx.jsonSchema.propertyNames) {
    delete ctx.jsonSchema.propertyNames;
  }
  if (ctx.jsonSchema.anyOf && ctx.jsonSchema.anyOf.some((s) => s.type === "null")) {
    ctx.jsonSchema.type = ctx.jsonSchema.anyOf.find((s) => s.type !== "null")?.type;
    ctx.jsonSchema.nullable = true;
    delete ctx.jsonSchema.anyOf;
  }
};
const deleteInvalidProperties = (schema) => {
  const object = { ...schema };
  delete object.id;
  delete object.$schema;
  delete object.$id;
  return object;
};
const zodSchemaToJson = (zodSchema, registry, io) => {
  const schemaRegistryEntry = registry.get(zodSchema);
  if (schemaRegistryEntry?.id) {
    return { $ref: getReferenceUri(schemaRegistryEntry.id, io) };
  }
  const tempID = "GEN";
  const tempRegistry = new $ZodRegistry();
  tempRegistry.add(zodSchema, { id: tempID });
  const {
    schemas: { [tempID]: result }
  } = toJSONSchema(tempRegistry, {
    metadata: registry,
    io,
    unrepresentable: "any",
    cycles: "ref",
    reused: "inline",
    /**
     * The uri option only allows customizing the base path of the `$ref`, and it automatically appends a path to it.
     * As a workaround, we set a placeholder that looks something like this:
     *
     * |       marker          | always added by zod | meta.id |
     * |__SCHEMA__PLACEHOLDER__|      #/$defs/       | User    |
     *
     * @example `__SCHEMA__PLACEHOLDER__#/$defs/User"`
     * @example `__SCHEMA__PLACEHOLDER__#/$defs/Group"`
     *
     * @see jsonSchemaReplaceRef
     * @see https://github.com/colinhacks/zod/issues/4750
     */
    uri: () => `__SCHEMA__PLACEHOLDER__`,
    override: (ctx) => getOverride(ctx, io)
  });
  const jsonSchema = deleteInvalidProperties(result);
  const jsonSchemaReplaceRef = JSON.stringify(jsonSchema).replaceAll(
    /"__SCHEMA__PLACEHOLDER__#\/\$defs\/(.+?)"/g,
    (_, id) => `"${getReferenceUri(id, io)}"`
  );
  return JSON.parse(jsonSchemaReplaceRef);
};
const zodRegistryToJson = (registry, io) => {
  const result = toJSONSchema(registry, {
    io,
    unrepresentable: "any",
    cycles: "ref",
    reused: "inline",
    uri: (id) => getReferenceUri(id, io),
    override: (ctx) => getOverride(ctx, io)
  }).schemas;
  const jsonSchemas = {};
  for (const id in result) {
    jsonSchemas[getSchemaId(id, io)] = deleteInvalidProperties(result[id]);
  }
  return jsonSchemas;
};
export {
  zodRegistryToJson,
  zodSchemaToJson
};
//# sourceMappingURL=zod-to-json.js.map
