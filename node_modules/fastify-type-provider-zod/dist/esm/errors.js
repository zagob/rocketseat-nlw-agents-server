import createError from "@fastify/error";
const InvalidSchemaError = createError("FST_ERR_INVALID_SCHEMA", "Invalid schema passed: %s", 500);
const ZodFastifySchemaValidationErrorSymbol = Symbol.for("ZodFastifySchemaValidationError");
const ResponseSerializationBase = createError(
  "FST_ERR_RESPONSE_SERIALIZATION",
  "Response doesn't match the schema",
  500
);
class ResponseSerializationError extends ResponseSerializationBase {
  constructor(method, url, options) {
    super({ cause: options.cause });
    this.method = method;
    this.url = url;
    this.cause = options.cause;
  }
  cause;
}
function isResponseSerializationError(value) {
  return "method" in value;
}
function isZodFastifySchemaValidationError(error) {
  return typeof error === "object" && error !== null && error[ZodFastifySchemaValidationErrorSymbol] === true;
}
function hasZodFastifySchemaValidationErrors(error) {
  return typeof error === "object" && error !== null && "validation" in error && Array.isArray(error.validation) && error.validation.length > 0 && isZodFastifySchemaValidationError(error.validation[0]);
}
function omit(obj, keys) {
  const result = {};
  for (const key of Object.keys(obj)) {
    if (!keys.includes(key)) {
      result[key] = obj[key];
    }
  }
  return result;
}
function createValidationError(error) {
  return error.issues.map((issue) => {
    return {
      [ZodFastifySchemaValidationErrorSymbol]: true,
      keyword: issue.code,
      instancePath: `/${issue.path.join("/")}`,
      schemaPath: `#/${issue.path.join("/")}/${issue.code}`,
      message: issue.message,
      params: {
        ...omit(issue, ["path", "code", "message"])
      }
    };
  });
}
export {
  InvalidSchemaError,
  ResponseSerializationError,
  createValidationError,
  hasZodFastifySchemaValidationErrors,
  isResponseSerializationError
};
//# sourceMappingURL=errors.js.map
