import { globalRegistry, safeParse, $ZodType } from "zod/v4/core";
import { ResponseSerializationError, createValidationError, InvalidSchemaError } from "./errors.js";
import { zodSchemaToJson, zodRegistryToJson } from "./zod-to-json.js";
const defaultSkipList = [
  "/documentation/",
  "/documentation/initOAuth",
  "/documentation/json",
  "/documentation/uiConfig",
  "/documentation/yaml",
  "/documentation/*",
  "/documentation/static/*"
];
const createJsonSchemaTransform = ({
  skipList = defaultSkipList,
  schemaRegistry = globalRegistry
}) => {
  return ({ schema, url }) => {
    if (!schema) {
      return {
        schema,
        url
      };
    }
    const { response, headers, querystring, body, params, hide, ...rest } = schema;
    const transformed = {};
    if (skipList.includes(url) || hide) {
      transformed.hide = true;
      return { schema: transformed, url };
    }
    const zodSchemas = { headers, querystring, body, params };
    for (const prop in zodSchemas) {
      const zodSchema = zodSchemas[prop];
      if (zodSchema) {
        transformed[prop] = zodSchemaToJson(zodSchema, schemaRegistry, "input");
      }
    }
    if (response) {
      transformed.response = {};
      for (const prop in response) {
        const zodSchema = resolveSchema(response[prop]);
        transformed.response[prop] = zodSchemaToJson(zodSchema, schemaRegistry, "output");
      }
    }
    for (const prop in rest) {
      const meta = rest[prop];
      if (meta) {
        transformed[prop] = meta;
      }
    }
    return { schema: transformed, url };
  };
};
const jsonSchemaTransform = createJsonSchemaTransform({});
const createJsonSchemaTransformObject = ({
  schemaRegistry = globalRegistry
}) => (input) => {
  if ("swaggerObject" in input) {
    console.warn("This package currently does not support component references for Swagger 2.0");
    return input.swaggerObject;
  }
  const inputSchemas = zodRegistryToJson(schemaRegistry, "input");
  const outputSchemas = zodRegistryToJson(schemaRegistry, "output");
  for (const key in outputSchemas) {
    if (inputSchemas[key]) {
      throw new Error(
        `Collision detected for schema "${key}". The is already an input schema with the same name.`
      );
    }
  }
  return {
    ...input.openapiObject,
    components: {
      ...input.openapiObject.components,
      schemas: {
        ...input.openapiObject.components?.schemas,
        ...inputSchemas,
        ...outputSchemas
      }
    }
  };
};
const jsonSchemaTransformObject = createJsonSchemaTransformObject({});
const validatorCompiler = ({ schema }) => (data) => {
  const result = safeParse(schema, data);
  if (result.error) {
    return { error: createValidationError(result.error) };
  }
  return { value: result.data };
};
function resolveSchema(maybeSchema) {
  if (maybeSchema instanceof $ZodType) {
    return maybeSchema;
  }
  if ("properties" in maybeSchema && maybeSchema.properties instanceof $ZodType) {
    return maybeSchema.properties;
  }
  throw new InvalidSchemaError(JSON.stringify(maybeSchema));
}
const createSerializerCompiler = (options) => ({ schema: maybeSchema, method, url }) => (data) => {
  const schema = resolveSchema(maybeSchema);
  const result = safeParse(schema, data);
  if (result.error) {
    throw new ResponseSerializationError(method, url, { cause: result.error });
  }
  return JSON.stringify(result.data, options?.replacer);
};
const serializerCompiler = createSerializerCompiler({});
export {
  createJsonSchemaTransform,
  createJsonSchemaTransformObject,
  createSerializerCompiler,
  jsonSchemaTransform,
  jsonSchemaTransformObject,
  serializerCompiler,
  validatorCompiler
};
//# sourceMappingURL=core.js.map
